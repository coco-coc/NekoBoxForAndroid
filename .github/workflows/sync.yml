name: Auto Sync Fork with Releases

on:
  schedule:
    - cron: '0 4 * * *'  # æ¯å¤© UTC 4 ç‚¹è‡ªåŠ¨è¿è¡Œ
  workflow_dispatch:      # å…è®¸æ‰‹åŠ¨è§¦å‘

jobs:
  sync-fork:
    runs-on: ubuntu-latest
    steps:
      # 1ï¸âƒ£ æ£€å‡ºä½ çš„ fork ä»“åº“
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          persist-credentials: false
          fetch-depth: 0

      # 2ï¸âƒ£ å®‰è£…å¿…è¦å·¥å…·
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl
          # å®‰è£… GitHub CLI
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          sudo apt-get update
          sudo apt-get install -y gh

      # 3ï¸âƒ£ é…ç½® Git å’Œè®¤è¯
      - name: Configure git and authentication
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # è®¾ç½®è®¤è¯URL
          AUTH_URL="https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"
          echo "AUTH_URL=$AUTH_URL" >> $GITHUB_ENV

      # 4ï¸âƒ£ å¤‡ä»½å·¥ä½œæµæ–‡ä»¶
      - name: Backup workflow files
        run: |
          mkdir -p /tmp/backup
          # å¤‡ä»½æ‰€æœ‰å·¥ä½œæµæ–‡ä»¶
          if [ -d ".github/workflows" ]; then
            cp -r .github/workflows/* /tmp/backup/
            echo "Backed up workflow files"
          else
            echo "No workflow files found to backup"
          fi

      # 5ï¸âƒ£ æ·»åŠ ä¸Šæ¸¸ä»“åº“å¹¶è·å–æ‰€æœ‰å†…å®¹
      - name: Add upstream and fetch
        run: |
          git remote remove upstream 2>/dev/null || true
          git remote add upstream https://github.com/5VNetwork/vproxy.git
          git fetch upstream --tags --force --prune
          git fetch upstream --force --prune '+refs/heads/*:refs/remotes/upstream/*'

      # 6ï¸âƒ£ åŒæ­¥æ‰€æœ‰åˆ†æ”¯ï¼ˆä¿ç•™å·¥ä½œæµæ–‡ä»¶ï¼‰
      - name: Sync branches with workflow preservation
        run: |
          # è·å–é»˜è®¤åˆ†æ”¯åç§°
          default_branch=$(git remote show origin | grep 'HEAD branch' | cut -d' ' -f5 || echo "main")
          echo "Default branch: $default_branch"
          
          # è·å–ä¸Šæ¸¸æ‰€æœ‰åˆ†æ”¯
          git show-ref | grep 'refs/remotes/upstream/' | while read hash ref; do
            branch_name=${ref#refs/remotes/upstream/}
            
            # è·³è¿‡ HEAD å¼•ç”¨
            if [ "$branch_name" = "HEAD" ]; then
              continue
            fi
            
            echo "Processing branch: $branch_name"
            
            # åˆ›å»ºæˆ–æ›´æ–°æœ¬åœ°åˆ†æ”¯
            if git show-ref --verify --quiet refs/heads/$branch_name; then
              echo "Updating existing branch: $branch_name"
              git checkout $branch_name
              
              # å¯¹äºé»˜è®¤åˆ†æ”¯ï¼Œä½¿ç”¨åˆå¹¶è€Œä¸æ˜¯é‡ç½®ï¼Œä»¥ä¿ç•™å·¥ä½œæµæ–‡ä»¶
              if [ "$branch_name" = "$default_branch" ]; then
                echo "Merging upstream changes to default branch (preserving workflows)"
                git merge --no-commit upstream/$branch_name
                
                # æ¢å¤å·¥ä½œæµæ–‡ä»¶
                if [ -d "/tmp/backup" ]; then
                  mkdir -p .github/workflows
                  cp -r /tmp/backup/* .github/workflows/
                  git add .github/workflows/
                fi
                
                # æäº¤åˆå¹¶
                if ! git diff --cached --quiet; then
                  git commit -m "Merge upstream changes and preserve workflows"
                fi
              else
                # å¯¹äºéé»˜è®¤åˆ†æ”¯ï¼Œä½¿ç”¨ç¡¬é‡ç½®
                git reset --hard upstream/$branch_name
              fi
            else
              echo "Creating new branch: $branch_name"
              git checkout -b $branch_name upstream/$branch_name
            fi
            
            # æ¨é€åˆ° origin - ä½¿ç”¨è®¤è¯ä¿¡æ¯
            echo "Pushing $branch_name to origin"
            git push ${{ env.AUTH_URL }} $branch_name --force
          done

      # 7ï¸âƒ£ æ”¹è¿›çš„æ ‡ç­¾åŒæ­¥æ–¹æ³•ï¼ˆä¿æŒæ—¶é—´æˆ³å¹¶ä½¿ç”¨è®¤è¯ï¼‰
      - name: Sync tags with timestamp preservation
        run: |
          # è·å–ä¸Šæ¸¸æ‰€æœ‰æ ‡ç­¾
          git fetch upstream --tags --force
          
          # è·å–æ‰€æœ‰ä¸Šæ¸¸æ ‡ç­¾åˆ—è¡¨
          upstream_tags=$(git ls-remote --tags upstream | awk '{print $2}' | cut -d '/' -f 3 | sort -V)
          
          # é€ä¸ªå¤„ç†æ¯ä¸ªæ ‡ç­¾ï¼Œä¿æŒæ—¶é—´æˆ³
          for tag in $upstream_tags; do
            echo "Processing tag: $tag"
            
            # æ£€æŸ¥æ ‡ç­¾æ˜¯å¦å·²å­˜åœ¨
            if git rev-parse "$tag" >/dev/null 2>&1; then
              # åˆ é™¤ç°æœ‰æ ‡ç­¾
              git tag -d "$tag"
              # åˆ é™¤è¿œç¨‹æ ‡ç­¾ï¼ˆä½¿ç”¨è®¤è¯ï¼‰
              git push ${{ env.AUTH_URL }} --delete "$tag" 2>/dev/null || true
            fi
            
            # ä»ä¸Šæ¸¸è·å–æ ‡ç­¾åŠå…¶æ—¶é—´æˆ³
            git fetch upstream "+refs/tags/$tag:refs/tags/$tag"
            
            # æ¨é€æ ‡ç­¾åˆ°originï¼ˆä½¿ç”¨è®¤è¯ï¼‰
            git push ${{ env.AUTH_URL }} "refs/tags/$tag" --force
          done

      # 8ï¸âƒ£ è·å–ä¸Šæ¸¸å‘å¸ƒåˆ—è¡¨å’Œæœ¬åœ°å‘å¸ƒåˆ—è¡¨ï¼ˆæŒ‰ç‰ˆæœ¬å·æ’åºï¼‰
      - name: Get release lists
        id: get_releases
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # è·å–ä¸Šæ¸¸æ‰€æœ‰å‘å¸ƒï¼ˆæŒ‰ç‰ˆæœ¬å·æ’åºï¼‰
          echo "Getting upstream releases..."
          upstream_releases=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/5VNetwork/vproxy/releases?per_page=100" | \
            jq -r '.[].tag_name' | sort -V)
          echo "Upstream releases: $upstream_releases"
          
          # è·å–æœ¬åœ°æ‰€æœ‰å‘å¸ƒï¼ˆæŒ‰ç‰ˆæœ¬å·æ’åºï¼‰
          echo "Getting local releases..."
          local_releases=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/${{ github.repository }}/releases?per_page=100" | \
            jq -r '.[].tag_name' | sort -V)
          echo "Local releases: $local_releases"
          
          # æ‰¾å‡ºéœ€è¦åŒæ­¥çš„æ–°å‘å¸ƒ
          new_releases=""
          for release in $upstream_releases; do
            if ! echo "$local_releases" | grep -q "^$release$"; then
              new_releases="$new_releases $release"
            fi
          done
          
          echo "New releases to sync: $new_releases"
          
          # è®¾ç½®è¾“å‡ºå˜é‡
          echo "new_releases=$new_releases" >> $GITHUB_OUTPUT

      # 9ï¸âƒ£ åªä¸‹è½½æ–°å‘å¸ƒçš„èµ„æºï¼ˆæŒ‰ç‰ˆæœ¬å·é¡ºåºï¼‰
      - name: Download new release assets
        if: steps.get_releases.outputs.new_releases != ''
        run: |
          mkdir -p releases
          new_releases="${{ steps.get_releases.outputs.new_releases }}"
          
          echo "New releases to process: $new_releases"
          
          # æŒ‰ç‰ˆæœ¬å·æ’åºæ–°å‘å¸ƒ
          sorted_releases=$(echo "$new_releases" | tr ' ' '\n' | sort -V | tr '\n' ' ')
          echo "Sorted releases: $sorted_releases"
          
          # å¾ªç¯å¤„ç†æ¯ä¸ªæ–°å‘å¸ƒï¼ˆæŒ‰ç‰ˆæœ¬å·é¡ºåºï¼‰
          for tag_name in $sorted_releases; do
            echo "Processing new release: $tag_name"
            
            # è·å–å‘å¸ƒè¯¦æƒ…
            release_info=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/5VNetwork/vproxy/releases/tags/$tag_name")
            
            # æ£€æŸ¥æ˜¯å¦æœ‰é”™è¯¯
            if echo "$release_info" | jq -e '.message' > /dev/null 2>&1; then
              echo "Error getting release $tag_name: $(echo "$release_info" | jq -r '.message')"
              continue
            fi
            
            release_id=$(echo "$release_info" | jq -r '.id')
            created_at=$(echo "$release_info" | jq -r '.created_at')
            published_at=$(echo "$release_info" | jq -r '.published_at')
            
            echo "Release ID: $release_id, Created: $created_at, Published: $published_at"
            
            # ä¸ºæ¯ä¸ªæ ‡ç­¾åˆ›å»ºå­ç›®å½•
            mkdir -p "releases/$tag_name"
            
            # ä¿å­˜å‘å¸ƒä¿¡æ¯åˆ°æ–‡ä»¶ï¼ˆåŒ…æ‹¬æ—¶é—´æˆ³ï¼‰
            echo "$release_info" > "releases/$tag_name/release_info.json"
            
            # ä¸‹è½½æ¯ä¸ªèµ„æº
            assets=$(echo "$release_info" | jq -r '.assets | length')
            echo "Found $assets assets for $tag_name"
            
            if [ "$assets" -gt 0 ]; then
              for i in $(seq 0 $(($assets-1))); do
                asset_name=$(echo "$release_info" | jq -r ".assets[$i].name")
                download_url=$(echo "$release_info" | jq -r ".assets[$i].browser_download_url")
                
                echo "Downloading asset: $asset_name"
                curl -L -o "releases/$tag_name/$asset_name" "$download_url" || echo "Failed to download $asset_name"
              done
            else
              echo "No assets found for $tag_name"
            fi
            
            # æ·»åŠ å»¶è¿Ÿä»¥é¿å…é€Ÿç‡é™åˆ¶
            sleep 2
          done

      # ğŸ”Ÿ åˆ›å»ºæ–°çš„ GitHub Releasesï¼ˆæŒ‰ç‰ˆæœ¬å·é¡ºåºï¼‰
      - name: Create new GitHub Releases with original timestamps
        if: steps.get_releases.outputs.new_releases != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          new_releases="${{ steps.get_releases.outputs.new_releases }}"
          
          # æŒ‰ç‰ˆæœ¬å·æ’åºæ–°å‘å¸ƒ
          sorted_releases=$(echo "$new_releases" | tr ' ' '\n' | sort -V | tr '\n' ' ')
          echo "Sorted releases for creation: $sorted_releases"
          
          # éå†æ‰€æœ‰æ–°å‘å¸ƒçš„èµ„æºï¼ˆæŒ‰ç‰ˆæœ¬å·é¡ºåºï¼‰
          for tag_name in $sorted_releases; do
            tag_dir="releases/$tag_name"
            
            if [ -d "$tag_dir" ]; then
              echo "Creating release: $tag_name"
              
              # è¯»å–å‘å¸ƒä¿¡æ¯
              release_info_file="$tag_dir/release_info.json"
              if [ -f "$release_info_file" ]; then
                release_name=$(jq -r '.name' "$release_info_file")
                release_notes=$(jq -r '.body' "$release_info_file")
                prerelease=$(jq -r '.prerelease' "$release_info_file")
                draft=$(jq -r '.draft' "$release_info_file")
                created_at=$(jq -r '.created_at' "$release_info_file")
                published_at=$(jq -r '.published_at' "$release_info_file")
                
                # è®¾ç½®å‘å¸ƒå‚æ•°
                prerelease_flag=""
                draft_flag=""
                if [ "$prerelease" = "true" ]; then
                  prerelease_flag="--prerelease"
                fi
                if [ "$draft" = "true" ]; then
                  draft_flag="--draft"
                fi
                
                # æ”¶é›†æ‰€æœ‰èµ„äº§æ–‡ä»¶ï¼ˆæ’é™¤ release_info.jsonï¼‰
                asset_files=()
                for file in "$tag_dir"/*; do
                  if [[ "$file" != *"release_info.json" ]]; then
                    asset_files+=("$file")
                  fi
                done
                
                # æ£€æŸ¥æ˜¯å¦æœ‰èµ„äº§æ–‡ä»¶
                if [ ${#asset_files[@]} -eq 0 ]; then
                  echo "No asset files found for $tag_name, skipping release creation"
                  continue
                fi
                
                echo "Found ${#asset_files[@]} asset files for $tag_name"
                
                # åˆ›å»ºå‘å¸ƒ - ä½¿ç”¨APIä»¥ä¿æŒåŸå§‹æ—¶é—´æˆ³
                if [ -n "$release_name" ] && [ "$release_name" != "null" ]; then
                  # ä½¿ç”¨GitHub APIåˆ›å»ºå‘å¸ƒï¼Œä»¥ä¾¿è®¾ç½®åˆ›å»ºæ—¶é—´
                  release_json=$(jq -n \
                    --arg tag_name "$tag_name" \
                    --arg name "$release_name" \
                    --arg body "$release_notes" \
                    --argjson prerelease "$prerelease" \
                    --argjson draft "$draft" \
                    --arg published_at "$published_at" \
                    '{
                      "tag_name": $tag_name,
                      "name": $name,
                      "body": $body,
                      "draft": $draft,
                      "prerelease": $prerelease,
                      "published_at": (if $published_at != "null" then $published_at else null end)
                    }')
                  
                  release_id=$(curl -s -H "Authorization: token $GH_TOKEN" \
                    -H "Accept: application/vnd.github.v3+json" \
                    -X POST \
                    -d "$release_json" \
                    "https://api.github.com/repos/${{ github.repository }}/releases" | \
                    jq -r '.id')
                  
                  if [ "$release_id" = "null" ]; then
                    echo "Failed to create release $tag_name, trying with gh CLI"
                    # å›é€€åˆ°gh CLI
                    gh release create --repo ${{ github.repository }} "$tag_name" \
                      --title "$release_name" \
                      --notes "$release_notes" \
                      $prerelease_flag \
                      $draft_flag || echo "Release $tag_name may already exist"
                  else
                    echo "Created release $tag_name with ID $release_id"
                  fi
                else
                  # ä½¿ç”¨gh CLIåˆ›å»ºå‘å¸ƒ
                  gh release create --repo ${{ github.repository }} "$tag_name" \
                    --notes "$release_notes" \
                    $prerelease_flag \
                    $draft_flag || echo "Release $tag_name may already exist"
                fi
                
                # å¦‚æœä½¿ç”¨APIåˆ›å»ºæˆåŠŸï¼Œä¸Šä¼ èµ„æº
                if [ -n "$release_id" ] && [ "$release_id" != "null" ]; then
                  for asset_file in "${asset_files[@]}"; do
                    echo "Uploading asset: $asset_file"
                    curl -s -H "Authorization: token $GH_TOKEN" \
                      -H "Content-Type: $(file -b --mime-type "$asset_file")" \
                      --data-binary @"$asset_file" \
                      "https://uploads.github.com/repos/${{ github.repository }}/releases/$release_id/assets?name=$(basename "$asset_file")" || echo "Failed to upload $asset_file"
                  done
                else
                  # ä½¿ç”¨gh CLIä¸Šä¼ èµ„æº
                  for asset_file in "${asset_files[@]}"; do
                    echo "Uploading asset: $asset_file"
                    gh release upload --repo ${{ github.repository }} "$tag_name" "$asset_file" || echo "Failed to upload $asset_file"
                  done
                fi
                
                echo "Created release: $tag_name with ${#asset_files[@]} assets"
              else
                echo "No release info found for $tag_name"
              fi
            else
              echo "No assets found for $tag_name"
            fi
            
            # æ·»åŠ å»¶è¿Ÿä»¥é¿å…é€Ÿç‡é™åˆ¶
            sleep 5
          done

      # æ¸…ç†ä¸‹è½½çš„èµ„æº
      - name: Clean up downloaded assets
        run: |
          rm -rf releases
          echo "Cleaned up downloaded assets"

      # å‘é€å®Œæˆé€šçŸ¥
      - name: Notify on completion
        run: |
          new_releases="${{ steps.get_releases.outputs.new_releases }}"
          if [ -n "$new_releases" ]; then
            echo "Sync completed at $(date)"
            echo "New releases synced: $new_releases"
          else
            echo "Sync completed at $(date)"
            echo "No new releases to sync"
          fi
          echo "Repository: https://github.com/${{ github.repository }}"