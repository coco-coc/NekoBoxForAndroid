name: Auto Sync Fork with Releases

on:
  schedule:
    - cron: '0 4 * * *'  # 每天 UTC 4 点自动运行
  workflow_dispatch:      # 允许手动触发

jobs:
  sync-fork:
    runs-on: ubuntu-latest
    steps:
      # 1️⃣ 检出你的 fork 仓库
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          persist-credentials: false
          fetch-depth: 0

      # 2️⃣ 安装必要工具
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl
          # 安装 GitHub CLI
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          sudo apt-get update
          sudo apt-get install -y gh

      # 3️⃣ 配置 Git 和认证
      - name: Configure git and authentication
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # 设置认证URL
          AUTH_URL="https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"
          echo "AUTH_URL=$AUTH_URL" >> $GITHUB_ENV

      # 4️⃣ 备份工作流文件
      - name: Backup workflow files
        run: |
          mkdir -p /tmp/backup
          # 备份所有工作流文件
          if [ -d ".github/workflows" ]; then
            cp -r .github/workflows/* /tmp/backup/
            echo "Backed up workflow files"
          else
            echo "No workflow files found to backup"
          fi

      # 5️⃣ 添加上游仓库并获取所有内容
      - name: Add upstream and fetch
        run: |
          git remote remove upstream 2>/dev/null || true
          git remote add upstream https://github.com/5VNetwork/vproxy.git
          git fetch upstream --tags --force --prune
          git fetch upstream --force --prune '+refs/heads/*:refs/remotes/upstream/*'

      # 6️⃣ 同步所有分支（保留工作流文件）
      - name: Sync branches with workflow preservation
        run: |
          # 获取默认分支名称
          default_branch=$(git remote show origin | grep 'HEAD branch' | cut -d' ' -f5 || echo "main")
          echo "Default branch: $default_branch"
          
          # 获取上游所有分支
          git show-ref | grep 'refs/remotes/upstream/' | while read hash ref; do
            branch_name=${ref#refs/remotes/upstream/}
            
            # 跳过 HEAD 引用
            if [ "$branch_name" = "HEAD" ]; then
              continue
            fi
            
            echo "Processing branch: $branch_name"
            
            # 创建或更新本地分支
            if git show-ref --verify --quiet refs/heads/$branch_name; then
              echo "Updating existing branch: $branch_name"
              git checkout $branch_name
              
              # 对于默认分支，使用合并而不是重置，以保留工作流文件
              if [ "$branch_name" = "$default_branch" ]; then
                echo "Merging upstream changes to default branch (preserving workflows)"
                git merge --no-commit upstream/$branch_name
                
                # 恢复工作流文件
                if [ -d "/tmp/backup" ]; then
                  mkdir -p .github/workflows
                  cp -r /tmp/backup/* .github/workflows/
                  git add .github/workflows/
                fi
                
                # 提交合并
                if ! git diff --cached --quiet; then
                  git commit -m "Merge upstream changes and preserve workflows"
                fi
              else
                # 对于非默认分支，使用硬重置
                git reset --hard upstream/$branch_name
              fi
            else
              echo "Creating new branch: $branch_name"
              git checkout -b $branch_name upstream/$branch_name
            fi
            
            # 推送到 origin - 使用认证信息
            echo "Pushing $branch_name to origin"
            git push ${{ env.AUTH_URL }} $branch_name --force
          done

      # 7️⃣ 改进的标签同步方法（保持时间戳并使用认证）
      - name: Sync tags with timestamp preservation
        run: |
          # 获取上游所有标签
          git fetch upstream --tags --force
          
          # 获取所有上游标签列表
          upstream_tags=$(git ls-remote --tags upstream | awk '{print $2}' | cut -d '/' -f 3 | sort -V)
          
          # 逐个处理每个标签，保持时间戳
          for tag in $upstream_tags; do
            echo "Processing tag: $tag"
            
            # 检查标签是否已存在
            if git rev-parse "$tag" >/dev/null 2>&1; then
              # 删除现有标签
              git tag -d "$tag"
              # 删除远程标签（使用认证）
              git push ${{ env.AUTH_URL }} --delete "$tag" 2>/dev/null || true
            fi
            
            # 从上游获取标签及其时间戳
            git fetch upstream "+refs/tags/$tag:refs/tags/$tag"
            
            # 推送标签到origin（使用认证）
            git push ${{ env.AUTH_URL }} "refs/tags/$tag" --force
          done

      # 8️⃣ 获取上游发布列表和本地发布列表（按版本号排序）
      - name: Get release lists
        id: get_releases
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # 获取上游所有发布（按版本号排序）
          echo "Getting upstream releases..."
          upstream_releases=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/5VNetwork/vproxy/releases?per_page=100" | \
            jq -r '.[].tag_name' | sort -V)
          echo "Upstream releases: $upstream_releases"
          
          # 获取本地所有发布（按版本号排序）
          echo "Getting local releases..."
          local_releases=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/${{ github.repository }}/releases?per_page=100" | \
            jq -r '.[].tag_name' | sort -V)
          echo "Local releases: $local_releases"
          
          # 找出需要同步的新发布
          new_releases=""
          for release in $upstream_releases; do
            if ! echo "$local_releases" | grep -q "^$release$"; then
              new_releases="$new_releases $release"
            fi
          done
          
          echo "New releases to sync: $new_releases"
          
          # 设置输出变量
          echo "new_releases=$new_releases" >> $GITHUB_OUTPUT

      # 9️⃣ 只下载新发布的资源（按版本号顺序）
      - name: Download new release assets
        if: steps.get_releases.outputs.new_releases != ''
        run: |
          mkdir -p releases
          new_releases="${{ steps.get_releases.outputs.new_releases }}"
          
          echo "New releases to process: $new_releases"
          
          # 按版本号排序新发布
          sorted_releases=$(echo "$new_releases" | tr ' ' '\n' | sort -V | tr '\n' ' ')
          echo "Sorted releases: $sorted_releases"
          
          # 循环处理每个新发布（按版本号顺序）
          for tag_name in $sorted_releases; do
            echo "Processing new release: $tag_name"
            
            # 获取发布详情
            release_info=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/5VNetwork/vproxy/releases/tags/$tag_name")
            
            # 检查是否有错误
            if echo "$release_info" | jq -e '.message' > /dev/null 2>&1; then
              echo "Error getting release $tag_name: $(echo "$release_info" | jq -r '.message')"
              continue
            fi
            
            release_id=$(echo "$release_info" | jq -r '.id')
            created_at=$(echo "$release_info" | jq -r '.created_at')
            published_at=$(echo "$release_info" | jq -r '.published_at')
            
            echo "Release ID: $release_id, Created: $created_at, Published: $published_at"
            
            # 为每个标签创建子目录
            mkdir -p "releases/$tag_name"
            
            # 保存发布信息到文件（包括时间戳）
            echo "$release_info" > "releases/$tag_name/release_info.json"
            
            # 下载每个资源
            assets=$(echo "$release_info" | jq -r '.assets | length')
            echo "Found $assets assets for $tag_name"
            
            if [ "$assets" -gt 0 ]; then
              for i in $(seq 0 $(($assets-1))); do
                asset_name=$(echo "$release_info" | jq -r ".assets[$i].name")
                download_url=$(echo "$release_info" | jq -r ".assets[$i].browser_download_url")
                
                echo "Downloading asset: $asset_name"
                curl -L -o "releases/$tag_name/$asset_name" "$download_url" || echo "Failed to download $asset_name"
              done
            else
              echo "No assets found for $tag_name"
            fi
            
            # 添加延迟以避免速率限制
            sleep 2
          done

      # 🔟 创建新的 GitHub Releases（按版本号顺序）
      - name: Create new GitHub Releases with original timestamps
        if: steps.get_releases.outputs.new_releases != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          new_releases="${{ steps.get_releases.outputs.new_releases }}"
          
          # 按版本号排序新发布
          sorted_releases=$(echo "$new_releases" | tr ' ' '\n' | sort -V | tr '\n' ' ')
          echo "Sorted releases for creation: $sorted_releases"
          
          # 遍历所有新发布的资源（按版本号顺序）
          for tag_name in $sorted_releases; do
            tag_dir="releases/$tag_name"
            
            if [ -d "$tag_dir" ]; then
              echo "Creating release: $tag_name"
              
              # 读取发布信息
              release_info_file="$tag_dir/release_info.json"
              if [ -f "$release_info_file" ]; then
                release_name=$(jq -r '.name' "$release_info_file")
                release_notes=$(jq -r '.body' "$release_info_file")
                prerelease=$(jq -r '.prerelease' "$release_info_file")
                draft=$(jq -r '.draft' "$release_info_file")
                created_at=$(jq -r '.created_at' "$release_info_file")
                published_at=$(jq -r '.published_at' "$release_info_file")
                
                # 设置发布参数
                prerelease_flag=""
                draft_flag=""
                if [ "$prerelease" = "true" ]; then
                  prerelease_flag="--prerelease"
                fi
                if [ "$draft" = "true" ]; then
                  draft_flag="--draft"
                fi
                
                # 收集所有资产文件（排除 release_info.json）
                asset_files=()
                for file in "$tag_dir"/*; do
                  if [[ "$file" != *"release_info.json" ]]; then
                    asset_files+=("$file")
                  fi
                done
                
                # 检查是否有资产文件
                if [ ${#asset_files[@]} -eq 0 ]; then
                  echo "No asset files found for $tag_name, skipping release creation"
                  continue
                fi
                
                echo "Found ${#asset_files[@]} asset files for $tag_name"
                
                # 创建发布 - 使用API以保持原始时间戳
                if [ -n "$release_name" ] && [ "$release_name" != "null" ]; then
                  # 使用GitHub API创建发布，以便设置创建时间
                  release_json=$(jq -n \
                    --arg tag_name "$tag_name" \
                    --arg name "$release_name" \
                    --arg body "$release_notes" \
                    --argjson prerelease "$prerelease" \
                    --argjson draft "$draft" \
                    --arg published_at "$published_at" \
                    '{
                      "tag_name": $tag_name,
                      "name": $name,
                      "body": $body,
                      "draft": $draft,
                      "prerelease": $prerelease,
                      "published_at": (if $published_at != "null" then $published_at else null end)
                    }')
                  
                  release_id=$(curl -s -H "Authorization: token $GH_TOKEN" \
                    -H "Accept: application/vnd.github.v3+json" \
                    -X POST \
                    -d "$release_json" \
                    "https://api.github.com/repos/${{ github.repository }}/releases" | \
                    jq -r '.id')
                  
                  if [ "$release_id" = "null" ]; then
                    echo "Failed to create release $tag_name, trying with gh CLI"
                    # 回退到gh CLI
                    gh release create --repo ${{ github.repository }} "$tag_name" \
                      --title "$release_name" \
                      --notes "$release_notes" \
                      $prerelease_flag \
                      $draft_flag || echo "Release $tag_name may already exist"
                  else
                    echo "Created release $tag_name with ID $release_id"
                  fi
                else
                  # 使用gh CLI创建发布
                  gh release create --repo ${{ github.repository }} "$tag_name" \
                    --notes "$release_notes" \
                    $prerelease_flag \
                    $draft_flag || echo "Release $tag_name may already exist"
                fi
                
                # 如果使用API创建成功，上传资源
                if [ -n "$release_id" ] && [ "$release_id" != "null" ]; then
                  for asset_file in "${asset_files[@]}"; do
                    echo "Uploading asset: $asset_file"
                    curl -s -H "Authorization: token $GH_TOKEN" \
                      -H "Content-Type: $(file -b --mime-type "$asset_file")" \
                      --data-binary @"$asset_file" \
                      "https://uploads.github.com/repos/${{ github.repository }}/releases/$release_id/assets?name=$(basename "$asset_file")" || echo "Failed to upload $asset_file"
                  done
                else
                  # 使用gh CLI上传资源
                  for asset_file in "${asset_files[@]}"; do
                    echo "Uploading asset: $asset_file"
                    gh release upload --repo ${{ github.repository }} "$tag_name" "$asset_file" || echo "Failed to upload $asset_file"
                  done
                fi
                
                echo "Created release: $tag_name with ${#asset_files[@]} assets"
              else
                echo "No release info found for $tag_name"
              fi
            else
              echo "No assets found for $tag_name"
            fi
            
            # 添加延迟以避免速率限制
            sleep 5
          done

      # 清理下载的资源
      - name: Clean up downloaded assets
        run: |
          rm -rf releases
          echo "Cleaned up downloaded assets"

      # 发送完成通知
      - name: Notify on completion
        run: |
          new_releases="${{ steps.get_releases.outputs.new_releases }}"
          if [ -n "$new_releases" ]; then
            echo "Sync completed at $(date)"
            echo "New releases synced: $new_releases"
          else
            echo "Sync completed at $(date)"
            echo "No new releases to sync"
          fi
          echo "Repository: https://github.com/${{ github.repository }}"